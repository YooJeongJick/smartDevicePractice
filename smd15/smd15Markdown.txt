목차
=
- JSON
- 예제
- 응용

<br>
<br>

JSON
=
JSON은 (JavaScript Object Notation)의 약자로,   
데이터를 전송할 때 사용되는 양식이다.   

<br>

JSON은 텍스트 기반인 것이 특징인데,   
상대적으로 읽고 작성하는 것이 쉬우며   
처리 속도가 빠르다는 장점이 있다.   

<br>

이와 같은 JSON의 양식은 JavaScript와 유사하지만   
독립적인 언어 형식이기 때문에 JavaScript 뿐만 아니라   
다양한 프로그래밍 환경에서도 제공되고 있다.   

<br>

해당 강의에서는 앞서 언급한 JSON 형식을 통해   
다양한 데이터를 전달하는 예제를 실행할 것이다.   

<br>
<br>

예제
=
실습에 들어가기 전에, Arduinojson 라이브러리를 설치한다.   
![NKakaoTalk_20240625_165052926](https://github.com/YooJeongJick/smartDevicePractice_2024/assets/145202997/e21ed7e8-e504-4bd8-b9b4-76f0bb855a49)   

<br>

해당 예제는 JSON 형식의 데이터에서     
특정한 값을 추출하는 활동으로    
이를 실행시키기 위한 코드는 아래와 같다.   
```
#include <ArduinoJson.h>
void setup() {
  // Initialize serial port
  Serial.begin(115200);
  while (!Serial) continue;
  delay(3000);

  StaticJsonDocument<96> doc;

  char json[] = R"rawliteral({
    "token_type":"bearer",
    "access_token":"c281d73b097",
    "expires_in":43199,
    "refresh_token":"0a0c90af08f",
    "refresh_token_expires_in":5184000,
    "scope":"account_email profile"
  })rawliteral";
  
  Serial.println(json);
  // Deserialize the JSON document
  DeserializationError error = deserializeJson(doc, json);
  // Test if parsing succeeds.
  if (error) {
    Serial.print(F("deserializeJson() failed: "));
    Serial.println(error.f_str());
    return;
  }
  // Fetch values.
  const char* access_token = doc["access_token"];
  const char* refresh_token = doc["refresh_token"];
  long expires_in = doc["expires_in"];
  // Print values.
  Serial.print("Access token : ");
  Serial.println(access_token);
  Serial.print("Refresh token : ");
  Serial.println(refresh_token);
  Serial.print("Expire time : ");
  Serial.println(expires_in);
}
void loop() {
  // not used in this example
}
```

<br>

위의 코드의 다음과 같은 부분은    
스택에 메모리를 할당함을 의미한다.   
```
  StaticJsonDocument<96> doc;
```

<br>

적절한 할당 메모리값을 계산해주는 사이트는 아래와 같다.   
```
https://arduinojson.org/v6/assistant/#/step1
```

<br>

char json[] 값을 기준으로 계산한 과정은 다음과 같다.   
```
  char json[] = R"rawliteral({
    "token_type":"bearer",
    "access_token":"c281d73b097",
    "expires_in":43199,
    "refresh_token":"0a0c90af08f",
    "refresh_token_expires_in":5184000,
    "scope":"account_email profile"
  })rawliteral";
```
![NKakaoTalk_20240625_165052926_01](https://github.com/YooJeongJick/smartDevicePractice_2024/assets/145202997/726faf76-cdf2-4d4b-8f41-d1c426a4abbc)   
![NKakaoTalk_20240625_165052926_02](https://github.com/YooJeongJick/smartDevicePractice_2024/assets/145202997/bf24c202-edc3-47e9-84bd-55786faed504)   
![NKakaoTalk_20240625_165052926_03](https://github.com/YooJeongJick/smartDevicePractice_2024/assets/145202997/a6018def-857d-4a4d-a622-41e4f08cb5ef)   
> 해당 코드에서는 이에 따라 96을 할당하였다.   

<br>
<br>

예제 코드의 실행 결과는 다음과 같다.   
![NKakaoTalk_20240625_165052926_04](https://github.com/YooJeongJick/smartDevicePractice_2024/assets/145202997/1c88ec6c-71c5-4773-a1c8-a678cab3dd5b)   

<br>
<br>

***

<br>
<br>

해당 예제는 입력된 데이터 값을     
JSON 형식으로 변환하는 활동으로,   
이를 실행시키기 위한 코드는 아래와 같다.   
```
#include <ArduinoJson.h>

void setup() {
  Serial.begin(115200);
  while (!Serial) continue;

  delay(3000);

  StaticJsonDocument<256> doc;

  doc["object_type"] = "text";
  doc["text"] = "텍스트 영역입니다. 최대 " + String(200)+ "자 표시 가능합니다.";

  doc["link"]["web_url"]  = "https://developers.kakao.com";
  doc["link"]["mobile_web_url"] = "https://developers.kakao.com";

  doc["button_title"] = "바로 확인";

  String jsonString ;
  String jsonPretyString ;

  // 최소화된 JSON을 생성하여 직렬 포트로 보냅니다.
  serializeJson(doc, jsonString);
  Serial.println(jsonString);
  /*
   { "object_type": "text", "text": "텍스트 영역입니다. 최대 200자 표시 가능합니다.", "link": { "web_url": "https://developers.kakao.com", "mobile_web_url": "https://developers.kakao.com" }, "button_title": "바로 확인" }
  */

  Serial.println();

  // prettified JSON을 생성하고 직렬 포트로 보냅니다.
  serializeJsonPretty(doc, jsonPretyString);
  Serial.println(jsonPretyString);
  /*
   {
        "object_type": "text",
        "text": "텍스트 영역입니다. 최대 200자 표시 가능합니다.",
        "link": {
            "web_url": "https://developers.kakao.com",
            "mobile_web_url": "https://developers.kakao.com"
        },
        "button_title": "바로 확인"
    }
  */
}

void loop() {
}
```
<br>

예제 코드의 실행 결과는 다음과 같다.   
![NKakaoTalk_20240625_165052926_05](https://github.com/YooJeongJick/smartDevicePractice_2024/assets/145202997/e0a75732-f5db-4902-a676-284d780481ca)   

<br>
<br>

응용
=
앞선 14주 차 강의에서 토양 습도 센서값을    
카카오톡으로 전달하는 활동을 하였는데,   
해당 강의는 이와 같은 내용에서   
JSON을 활용하도록 수정할 것이다.   

<br>

응용 예제를 위한 기본 설정은 전과 같으며   
코드 내용만 다음과 같이 변경되었다.   
```
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>

const char* ssid = "Your_SSID";          // 사용하는 WiFi 네트워크 이름 (SSID)
const char* password = "Your_Password";  // 사용하는 WiFi 네트워크 비밀번호

const String rest_api_key = "REST API KEY";
String access_token = "Access token";
String refresh_token = "Refresh token";

#define MsgSendInterval 3600  // 60 * 60 초, 즉 한시간 간격으로 전송
long timeout = 3600;          //시간을 초로 나타냄
int sensorValue = 0;
int sensorPin = 34;

void setup() {
  Serial.begin(115200);

  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(1000);
  }
  Serial.print("\nConnected to WiFi : ");
  Serial.println(WiFi.localIP());
}
void loop() {
  if (timeout++ > MsgSendInterval)  // 1시간(60 * 60)에 1번씩 전송
  {
    if (isAccessTokenExpired() == true) {
      if (update_access_token() == false) {
        Serial.println("Access token update failed");
      }
    }
    sensorValue = analogRead(sensorPin);
    send_message();
    timeout = 0;
  }

  delay(1000);
}


// str문자열에서 start_string와 end_string사이의 문자열을 추출하는 함수
/*
String extract_string(String str, String start_string, String end_string)
{
  int index1 = str.indexOf(start_string) + start_string.length();
  int index2 = str.indexOf(end_string, index1);
  String value = str.substring(index1, index2);
  return value;
}
*/

bool isAccessTokenExpired() {
  HTTPClient http;
  bool returnVal = true;

  StaticJsonDocument<100> doc;
  /*
curl -v -X GET "https://kapi.kakao.com/v1/user/access_token_info" \
  -H "Authorization: Bearer ${ACCESS_TOKEN}"
*/
  if (!http.begin("https://kapi.kakao.com/v1/user/access_token_info")) {
    Serial.println("\nfailed to begin http\n");
  }
  http.addHeader("Authorization", "Bearer " + access_token);

  int httpCode = http.GET();

  // httpCode will be negative on error
  if (httpCode > 0) {
    // file found at server
    if (httpCode == HTTP_CODE_OK) {
      String payload = http.getString();
      Serial.println(payload);
      // Deserialize the JSON document
      DeserializationError error = deserializeJson(doc, payload);
      long expire_time = doc["expires_in"];
      Serial.println(expire_time);
      if (expire_time > 0) {
        returnVal = false;
      } else {
        returnVal = true;
      }
    }
  } else {
    Serial.printf("[HTTP] GET... failed, error: %s\n",
                  http.errorToString(httpCode).c_str());
  }
  http.end();
  return returnVal;
}

void send_message() {
  HTTPClient http;

  StaticJsonDocument<300> doc;

  String url = "https://kapi.kakao.com/v2/api/talk/memo/default/send";
  if (!http.begin(url)) {
    Serial.println("\nfailed to begin http\n");
  }

  http.addHeader("Authorization", "Bearer " + access_token);
  http.addHeader("Content-Type", "application/x-www-form-urlencoded");

  int http_code;
  /* 카카오톡 default 템플릿
   template_object={
        "object_type": "text",
        "text": "텍스트 영역입니다. 최대 200자 표시 가능합니다.",
        "link": {
            "web_url": "https://developers.kakao.com",
            "mobile_web_url": "https://developers.kakao.com"
        },
        "button_title": "바로 확인"
    }
    */
  doc["object_type"] = "text";
  doc["text"] = "토양 센서 값 :" + String(sensorValue);
  //doc["link"]["web_url"] = "https://www.naver.com";
  JsonObject obj = doc.createNestedObject();
  doc["link"] = obj;

  String data;
  // Generate the minified JSON and send it to the Serial port.
  //
  serializeJson(doc, data);
  Serial.println(data);

  http_code = http.POST("template_object=" + data);
  Serial.print("HTTP Response code: ");
  Serial.println(http_code);

  String response;
  if (http_code > 0) {
    response = http.getString();
    Serial.println(response);
  }

  http.end();
}

/*
curl -v -X POST "https://kauth.kakao.com/oauth/token" \
 -H "Content-Type: application/x-www-form-urlencoded" \
 -d "grant_type=refresh_token" \
 -d "client_id=${REST_API_KEY}" \
 -d "refresh_token=${USER_REFRESH_TOKEN}"
*/
bool update_access_token() {
  HTTPClient http;
  bool retVal = false;
  StaticJsonDocument<400> doc;

  String url = "https://kauth.kakao.com/oauth/token";
  String nrefresh_token = "";
  if (!http.begin(url)) {
    Serial.println("\nfailed to begin http\n");
  }
  http.addHeader("Content-Type", "application/x-www-form-urlencoded");
  int http_code;
  String data = "grant_type=refresh_token&client_id=" + rest_api_key + "&refresh_token=" + refresh_token;
  Serial.println(data);
  http_code = http.POST(data);
  Serial.print("HTTP Response code: ");
  Serial.println(http_code);

  String response;
  if (http_code > 0) {
    response = http.getString();
    Serial.println(response);

    DeserializationError error = deserializeJson(doc, response);

    const char* atoken = doc["access_token"];
    const char* rtoken = doc["refresh_token"];

    Serial.print("Access token : ");
    Serial.println(atoken);
    Serial.print("New refresh token : ");
    Serial.println(rtoken);

    access_token = atoken;
    //만료 1개월전부터 갱신되므로 data가 없을 수도 있음
    if (rtoken != NULL) {
      refresh_token = rtoken;
    }

    retVal = true;
  } else {
    retVal = false;
  }
  http.end();
  return retVal;
}
```

<br>

이에 대한 실행 결과는 예전과 동일하다.   
![NKakaoTalk_20240625_165052926_06](https://github.com/YooJeongJick/smartDevicePractice_2024/assets/145202997/e2340e5e-dd7a-4210-b8f1-b8282e910572)   
